/**
 * SacredGitHooks.js - Sacred Git Hooks for Evolutionary Development
 * Implements pre-commit and post-commit hooks for automatic evolution triggers
 */

import { EventEmitter } from 'events';
import chalk from 'chalk';
import fs from 'fs-extra';
import path from 'path';
import { execSync } from 'child_process';
import { logger } from '../core/Logger.js';
import { ashvatthaTree } from '../core/GodRealms.js';
import { treeCoordinator } from '../core/TreeCoordinator.js';
import MutationBrancher from './MutationBrancher.js';
import EvolutionBirther from './EvolutionBirther.js';

export class SacredGitHooks extends EventEmitter {
  constructor(repoPath = '.') {
    super();
    this.repoPath = path.resolve(repoPath);
    this.hooksPath = path.join(this.repoPath, '.git', 'hooks');
    this.sacredHooksPath = path.join(this.repoPath, '.gaia-hooks');
    this.mutationBrancher = new MutationBrancher(repoPath);
    this.evolutionBirther = new EvolutionBirther(repoPath);
    
    // Hook configurations
    this.hookConfigs = {
      'pre-commit': {
        enabled: true,
        triggers: ['divine_inspection', 'balance_check', 'fitness_evaluation'],
        gods: ['heimdall', 'odin'] // Watchful gods for pre-commit
      },
      'post-commit': {
        enabled: true,
        triggers: ['evolution_spawn', 'lineage_branch', 'divine_blessing'],
        gods: ['brahma', 'shiva'] // Creative and transformative gods
      },
      'pre-push': {
        enabled: true,
        triggers: ['final_blessing', 'tree_harmony'],
        gods: ['zeus', 'odin'] // Supreme oversight
      },
      'post-merge': {
        enabled: true,
        triggers: ['evolution_celebration', 'balance_restoration'],
        gods: ['apollo', 'freyr'] // Celebration and growth
      }
    };
    
    logger.info('SacredGitHooks initialized for evolutionary development');
  }

  // Install all sacred git hooks
  async installSacredHooks() {
    try {
      console.log(chalk.magenta('\nüîÆ Installing Sacred Git Hooks'));
      
      // Ensure hooks directory exists
      await fs.ensureDir(this.hooksPath);
      await fs.ensureDir(this.sacredHooksPath);
      
      // Install each hook
      for (const [hookName, config] of Object.entries(this.hookConfigs)) {
        if (config.enabled) {
          await this.installHook(hookName, config);
        }
      }
      
      // Create sacred hooks configuration
      await this.createSacredHooksConfig();
      
      console.log(chalk.green('‚ú® All sacred hooks installed successfully!'));
      logger.info('Sacred git hooks installed');
      
      this.emit('hooks:installed');
      return true;
      
    } catch (error) {
      logger.error('Failed to install sacred hooks', { error: error.message });
      throw error;
    }
  }

  // Install individual hook
  async installHook(hookName, config) {
    const hookPath = path.join(this.hooksPath, hookName);
    const sacredHookPath = path.join(this.sacredHooksPath, `${hookName}.js`);
    
    try {
      // Create sacred hook implementation
      await this.createSacredHookImplementation(hookName, config, sacredHookPath);
      
      // Create git hook that calls sacred implementation
      const gitHookScript = this.createGitHookScript(hookName, sacredHookPath);
      await fs.writeFile(hookPath, gitHookScript, { mode: 0o755 });
      
      console.log(chalk.green(`   ‚úÖ ${hookName} hook installed`));
      logger.debug('Sacred hook installed', { hookName, path: hookPath });
      
    } catch (error) {
      logger.error('Failed to install hook', { hookName, error: error.message });
      throw error;
    }
  }

  // Create sacred hook implementation
  async createSacredHookImplementation(hookName, config, hookPath) {
    const hookImplementation = `#!/usr/bin/env node
/**
 * Sacred ${hookName} Hook - Divine Evolutionary Trigger
 * Automatically generated by SacredGitHooks.js
 */

import { SacredGitHooks } from '../|_trunk/heartwood/SacredGitHooks.js';

const hooks = new SacredGitHooks('.');

// Execute sacred ${hookName} hook
hooks.execute${hookName.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join('')}Hook()
  .then(() => {
    process.exit(0);
  })
  .catch((error) => {
    console.error('Sacred ${hookName} hook failed:', error.message);
    process.exit(1);
  });
`;

    await fs.writeFile(hookPath, hookImplementation, { mode: 0o755 });
  }

  // Create git hook script that calls sacred implementation
  createGitHookScript(hookName, sacredHookPath) {
    return `#!/bin/bash
# Sacred Git Hook - ${hookName}
# This hook is managed by Gaia Sacred Hooks system

# Check if Node.js is available
if ! command -v node &> /dev/null; then
    echo "Node.js is required for sacred hooks"
    exit 1
fi

# Execute sacred hook
node "${sacredHookPath}" "$@"
`;
  }

  // Execute pre-commit hook
  async executePreCommitHook() {
    console.log(chalk.cyan('üîç Sacred Pre-Commit Hook: Divine Inspection'));
    
    try {
      const config = this.hookConfigs['pre-commit'];
      
      // Invoke watchful gods for inspection
      for (const god of config.gods) {
        const inspection = await ashvatthaTree.invokeGod(god, 
          'Inspect code changes before commit');
        console.log(chalk.yellow(`   üëÅÔ∏è  ${god}: ${inspection.intervention || 'Code blessed'}`));
      }
      
      // Check tree balance
      const balance = treeCoordinator.getTreeHealth().trunk.balance;
      if (Math.abs(balance) > 80) {
        console.log(chalk.red(`   ‚ö†Ô∏è  Tree imbalance detected: ${balance}`));
        console.log(chalk.yellow(`   üîÆ Consider balancing before commit`));
      }
      
      // Fitness evaluation of current changes
      const fitness = await this.evaluateChangesFitness();
      console.log(chalk.cyan(`   üí™ Changes fitness: ${fitness.toFixed(2)}`));
      
      if (fitness < 30) {
        console.log(chalk.red(`   ‚ö†Ô∏è  Low fitness changes detected`));
        console.log(chalk.yellow(`   üîÆ Consider improving before commit`));
      }
      
      this.emit('hook:pre-commit', { balance, fitness });
      logger.info('Pre-commit hook executed', { balance, fitness });
      
    } catch (error) {
      logger.error('Pre-commit hook failed', { error: error.message });
      throw error;
    }
  }

  // Execute post-commit hook
  async executePostCommitHook() {
    console.log(chalk.green('üå± Sacred Post-Commit Hook: Evolution Spawn'));
    
    try {
      const config = this.hookConfigs['post-commit'];
      
      // Get commit info
      const commitHash = execSync('git rev-parse HEAD', { encoding: 'utf-8' }).trim();
      const commitMessage = execSync('git log -1 --pretty=%B', { encoding: 'utf-8' }).trim();
      
      console.log(chalk.gray(`   üìù Commit: ${commitHash.substring(0, 8)}`));
      console.log(chalk.gray(`   üí¨ Message: ${commitMessage.split('\n')[0]}`));
      
      // Invoke creative gods for evolution spawning
      for (const god of config.gods) {
        const blessing = await ashvatthaTree.invokeGod(god,
          `Bless new commit and spawn evolution: ${commitHash}`);
        console.log(chalk.green(`   üîÆ ${god}: ${blessing.intervention || 'Evolution blessed'}`));
      }
      
      // Spawn evolution lineage for significant commits
      const commitSignificance = await this.assessCommitSignificance(commitMessage);
      
      if (commitSignificance.shouldSpawnEvolution) {
        console.log(chalk.magenta(`   üß¨ Spawning evolution lineage`));
        
        const lineage = await this.evolutionBirther.birthNewLineage(
          'main',
          { light: 'apollo', shadow: 'shiva' },
          commitSignificance.species
        );
        
        console.log(chalk.green(`   ‚ú® Evolution lineage born: ${lineage.id}`));
        this.emit('evolution:spawned', { commit: commitHash, lineage });
      }
      
      // Create mutation branch for experimental changes
      if (commitSignificance.experimentalPotential > 70) {
        const mutation = await this.mutationBrancher.createMutationBranch(
          'experimental',
          'main',
          'loki' // Adaptive trickery god
        );
        
        console.log(chalk.yellow(`   üß¨ Experimental mutation: ${mutation.id}`));
      }
      
      this.emit('hook:post-commit', { 
        commit: commitHash, 
        significance: commitSignificance 
      });
      
      logger.info('Post-commit hook executed', { 
        commit: commitHash,
        spawned: commitSignificance.shouldSpawnEvolution 
      });
      
    } catch (error) {
      logger.error('Post-commit hook failed', { error: error.message });
      throw error;
    }
  }

  // Execute pre-push hook
  async executePrePushHook() {
    console.log(chalk.magenta('üëë Sacred Pre-Push Hook: Final Divine Blessing'));
    
    try {
      const config = this.hookConfigs['pre-push'];
      
      // Invoke supreme gods for final blessing
      for (const god of config.gods) {
        const blessing = await ashvatthaTree.invokeGod(god,
          'Provide final blessing before push to remote');
        console.log(chalk.magenta(`   üëë ${god}: ${blessing.intervention || 'Push blessed'}`));
      }
      
      // Check tree harmony
      const harmony = treeCoordinator.assessTreeHarmony();
      console.log(chalk.cyan(`   ‚öñÔ∏è  Tree harmony: ${harmony.score.toFixed(2)}`));
      
      if (harmony.score < 60) {
        console.log(chalk.red(`   ‚ö†Ô∏è  Tree harmony too low for push`));
        console.log(chalk.yellow(`   üîÆ Consider harmonizing tree before push`));
        throw new Error('Tree harmony insufficient for push');
      }
      
      this.emit('hook:pre-push', { harmony });
      logger.info('Pre-push hook executed', { harmony: harmony.score });
      
    } catch (error) {
      logger.error('Pre-push hook failed', { error: error.message });
      throw error;
    }
  }

  // Execute post-merge hook
  async executePostMergeHook() {
    console.log(chalk.rainbow('üéâ Sacred Post-Merge Hook: Evolution Celebration'));
    
    try {
      const config = this.hookConfigs['post-merge'];
      
      // Invoke celebration gods
      for (const god of config.gods) {
        const celebration = await ashvatthaTree.invokeGod(god,
          'Celebrate successful merge and evolution');
        console.log(chalk.green(`   üéâ ${god}: ${celebration.intervention || 'Merge celebrated'}`));
      }
      
      // Restore tree balance after merge
      const balanceRestoration = treeCoordinator.balanceForces(10, 10);
      console.log(chalk.cyan(`   ‚öñÔ∏è  Balance restored: ${balanceRestoration.newBalance}`));
      
      // Assess merged evolution fitness
      const mergeCommit = execSync('git rev-parse HEAD', { encoding: 'utf-8' }).trim();
      const fitness = await this.evaluateChangesFitness();
      
      console.log(chalk.green(`   üí™ Merged evolution fitness: ${fitness.toFixed(2)}`));
      
      this.emit('hook:post-merge', { 
        commit: mergeCommit, 
        fitness, 
        balance: balanceRestoration 
      });
      
      logger.info('Post-merge hook executed', { 
        commit: mergeCommit, 
        fitness 
      });
      
    } catch (error) {
      logger.error('Post-merge hook failed', { error: error.message });
      throw error;
    }
  }

  // Evaluate fitness of current changes
  async evaluateChangesFitness() {
    try {
      // Get staged files
      const stagedFiles = execSync('git diff --cached --name-only', { encoding: 'utf-8' })
        .split('\n')
        .filter(f => f.trim());
      
      let fitness = 0;
      
      // Base fitness from number of files
      fitness += stagedFiles.length * 10;
      
      // File type bonuses
      const fileTypeScores = {
        '.js': 15,
        '.ts': 18,
        '.json': 10,
        '.md': 8,
        '.yml': 12,
        '.yaml': 12
      };
      
      stagedFiles.forEach(file => {
        const ext = path.extname(file);
        fitness += fileTypeScores[ext] || 5;
      });
      
      // Check for critical system files
      const criticalFiles = stagedFiles.filter(f => 
        f.includes('gaia.js') || 
        f.includes('divine') || 
        f.includes('evolution') ||
        f.includes('god')
      );
      
      fitness += criticalFiles.length * 20;
      
      // Get diff stats
      const diffStats = execSync('git diff --cached --shortstat', { encoding: 'utf-8' });
      const insertions = (diffStats.match(/(\d+) insertions?/) || [0, 0])[1];
      const deletions = (diffStats.match(/(\d+) deletions?/) || [0, 0])[1];
      
      fitness += parseInt(insertions) * 0.5;
      fitness += parseInt(deletions) * 0.3; // Deletions are good but less valuable
      
      return Math.min(100, Math.max(0, fitness));
      
    } catch (error) {
      logger.warn('Fitness evaluation failed', { error: error.message });
      return 50; // Default fitness
    }
  }

  // Assess commit significance for evolution spawning
  async assessCommitSignificance(commitMessage) {
    const significance = {
      shouldSpawnEvolution: false,
      species: 'hybrid',
      experimentalPotential: 0,
      divineImportance: 0
    };
    
    const message = commitMessage.toLowerCase();
    
    // Keywords that indicate high significance
    const significantKeywords = {
      'breaking': { score: 90, species: 'transformation' },
      'major': { score: 80, species: 'architecture' },
      'feat': { score: 70, species: 'hybrid' },
      'feature': { score: 70, species: 'hybrid' },
      'refactor': { score: 60, species: 'optimization' },
      'performance': { score: 65, species: 'performance' },
      'security': { score: 75, species: 'security' },
      'divine': { score: 95, species: 'experimental' },
      'evolution': { score: 85, species: 'experimental' },
      'god': { score: 80, species: 'experimental' }
    };
    
    for (const [keyword, config] of Object.entries(significantKeywords)) {
      if (message.includes(keyword)) {
        significance.divineImportance = Math.max(significance.divineImportance, config.score);
        significance.species = config.species;
      }
    }
    
    // Experimental potential based on commit patterns
    if (message.includes('experiment') || message.includes('test') || message.includes('wip')) {
      significance.experimentalPotential = 80;
    } else if (message.includes('hack') || message.includes('temp') || message.includes('quick')) {
      significance.experimentalPotential = 60;
    }
    
    // Should spawn evolution if significance is high enough
    significance.shouldSpawnEvolution = significance.divineImportance >= 60;
    
    return significance;
  }

  // Create sacred hooks configuration file
  async createSacredHooksConfig() {
    const config = {
      version: '1.0.0',
      installed: new Date(),
      hooks: this.hookConfigs,
      repository: this.repoPath,
      sacredPath: this.sacredHooksPath,
      documentation: {
        description: 'Sacred Git Hooks for Divine Evolutionary Development',
        features: [
          'Pre-commit divine inspection and fitness evaluation',
          'Post-commit evolution spawning and lineage creation',
          'Pre-push final blessing and harmony check',
          'Post-merge celebration and balance restoration'
        ],
        gods: {
          preCommit: ['heimdall', 'odin'],
          postCommit: ['brahma', 'shiva'],
          prePush: ['zeus', 'odin'],
          postMerge: ['apollo', 'freyr']
        }
      }
    };
    
    const configPath = path.join(this.sacredHooksPath, 'sacred-hooks.json');
    await fs.writeJson(configPath, config, { spaces: 2 });
    
    console.log(chalk.cyan(`   üìù Sacred hooks configuration: ${configPath}`));
  }

  // Uninstall sacred hooks
  async uninstallSacredHooks() {
    try {
      console.log(chalk.red('üóëÔ∏è  Uninstalling Sacred Git Hooks'));
      
      for (const hookName of Object.keys(this.hookConfigs)) {
        const hookPath = path.join(this.hooksPath, hookName);
        
        if (await fs.pathExists(hookPath)) {
          await fs.remove(hookPath);
          console.log(chalk.gray(`   üóëÔ∏è  Removed ${hookName}`));
        }
      }
      
      // Remove sacred hooks directory
      if (await fs.pathExists(this.sacredHooksPath)) {
        await fs.remove(this.sacredHooksPath);
        console.log(chalk.gray(`   üóëÔ∏è  Removed sacred hooks directory`));
      }
      
      console.log(chalk.green('‚úÖ Sacred hooks uninstalled'));
      this.emit('hooks:uninstalled');
      
    } catch (error) {
      logger.error('Failed to uninstall sacred hooks', { error: error.message });
      throw error;
    }
  }

  // Get hooks status
  getHooksStatus() {
    const status = {
      installed: [],
      missing: [],
      configured: Object.keys(this.hookConfigs)
    };
    
    for (const hookName of Object.keys(this.hookConfigs)) {
      const hookPath = path.join(this.hooksPath, hookName);
      
      if (fs.existsSync(hookPath)) {
        status.installed.push(hookName);
      } else {
        status.missing.push(hookName);
      }
    }
    
    return status;
  }

  // Test hooks system
  async testHooks() {
    console.log(chalk.cyan('üß™ Testing Sacred Hooks System'));
    
    try {
      const status = this.getHooksStatus();
      console.log(chalk.green(`   ‚úÖ Installed: ${status.installed.join(', ')}`));
      
      if (status.missing.length > 0) {
        console.log(chalk.red(`   ‚ùå Missing: ${status.missing.join(', ')}`));
      }
      
      // Test each hook
      for (const hookName of status.installed) {
        const hookPath = path.join(this.hooksPath, hookName);
        const isExecutable = (await fs.stat(hookPath)).mode & parseInt('111', 8);
        
        console.log(chalk.cyan(`   üîç ${hookName}: ${isExecutable ? 'executable' : 'not executable'}`));
      }
      
      console.log(chalk.green('‚úÖ Hooks system test complete'));
      return true;
      
    } catch (error) {
      logger.error('Hooks test failed', { error: error.message });
      return false;
    }
  }
}

export default SacredGitHooks;